#include "gcp/util/common/IdlGenerator.h"
#include "gcp/util/common/Exception.h"
#include "gcp/util/common/String.h"
#include "gcp/util/common/SpecificName.h"

#include<iostream>

using namespace std;

using namespace gcp::util;

/**.......................................................................
 * Constructor.
 */
IdlGenerator::IdlGenerator(std::string sourceFileName, std::string dir) : 
  dir_(dir), sourceFileName_(sourceFileName)
{
  parseFile();
}

IdlGenerator::IdlGenerator(std::string sourceFileName) : 
  dir_("."), sourceFileName_(sourceFileName)
{
  parseFile();
}

void IdlGenerator::parseFile()
{
  string s;
  ostringstream os;

  String fileParser(sourceFileName_);
  sourceFilePrefix_ = fileParser.findNextStringSeparatedByChars(".").str();

  outputPrefix_   = sourceFilePrefix_;
  outputCcSuffix_ = "cc";

  os << dir_ << "/" << sourceFileName_;

  COUT("Attempting to open: " << os.str());

  std::ifstream inputFile(os.str().c_str());

  while(getline(inputFile, s)) {
    String str(s);

    if(str.contains("argc") && str.contains("IDL_VPTR") && str.contains("argv")) {

      if(str.findNextString().str() != "static")
	ThrowError("Function dclaration must be static: " << s);

      String retVal = str.findNextString();
      String fnName = str.findNextStringSeparatedByChars(" (");

      if(retVal.str() == "IDL_VPTR")
	functions_.push_back(fnName.str());
      else {
	procedures_.push_back(fnName.str());
	procRetVals_.push_back(retVal.str());
      }
    }
  }

#if 0
  COUT("Functions: " << functions_.size());
  for(unsigned i=0; i < functions_.size(); i++)
    COUT(functions_[i]);

  COUT("Procedures: " << procedures_.size());
  for(unsigned i=0; i < procedures_.size(); i++)
    COUT(procedures_[i]);
#endif

  inputFile.close();
}

/**.......................................................................
 * Destructor.
 */
IdlGenerator::~IdlGenerator() {}

void IdlGenerator::outputHeaderFile()
{
  std::ostringstream os;

  std::string prefixCopy = sourceFilePrefix_;

  os << dir_ << "/" << SpecificName::experimentName() << "Idl" << prefixCopy << ".h";

  std::ofstream fout(os.str().c_str(), ios::out);

  os.str("");
  os << "GCP_IDL_" << SpecificName::experimentName() << "Idl" << prefixCopy << "_H";
 
  std::string caps = os.str();
  for(unsigned i=0; i < caps.size(); i++)
    caps[i] = toupper(caps[i]);

  fout << "#ifndef " << caps << std::endl;
  fout << "#define " << caps << std::endl << std::endl;

  fout << "//=======================================================================" << std::endl;
  fout << "// Auto-generated by IdlGenerator from " << sourceFileName_                << std::endl;
  fout << "//"                                                                        << std::endl;
  fout << "// This is a required header file for compilation into a dynamically     " << std::endl;
  fout << "// loadable IDL module                                                   " << std::endl;
  fout << "//=======================================================================" << std::endl << std::endl;

  fout << "// Function declarations" << std::endl << std::endl;

  for(unsigned i=0; i < functions_.size(); i++)
    fout << "static IDL_VPTR " << functions_[i] << "(int argc, IDL_VPTR* argv);" << std::endl << std::endl;

  fout << "// Procedure declarations" << std::endl << std::endl;

  for(unsigned i=0; i < procedures_.size(); i++)
    fout << "static " << procRetVals_[i] << " " << procedures_[i] << "(int argc, IDL_VPTR* argv);" << std::endl;

  fout << std::endl;
  fout << "#endif // End #ifndef GCP_IDL_" << caps << std::endl;

  fout.close();
}

void IdlGenerator::outputLoadFile()
{
  std::ostringstream os, is;

  std::string prefixCopy = sourceFilePrefix_;

  is << dir_ << "/" << sourceFileName_;
  os << dir_ << "/" << SpecificName::experimentName() << "Idl" << prefixCopy << "Load" << ".cc";

  // Open the files

  std::ifstream fin(os.str().c_str());
  std::ofstream fout(os.str().c_str(), ios::out);

  os.str("");
  os << SpecificName::experimentName() << "Idl" << prefixCopy;
  std::string filePrefix = os.str();

  fout << "//=======================================================================" << std::endl;
  fout << "// Auto-generated by IdlGenerator from " << sourceFileName_                << std::endl;
  fout << "//"                                                                        << std::endl;
  fout << "// This file contains the definition of the IDL_Load() function"           << std::endl;
  fout << "// required for compilation into a dynamically loadable IDL module"        << std::endl;
  fout << "//=======================================================================" << std::endl << std::endl;

  fout << "// Include definitions of the functions to be loaded"  << std::endl << std::endl;
  fout << "#include \"gcp/idl/common/" << filePrefix << ".h\"" << std::endl << std::endl;


  fout << "// We must declare this function with the extern \"C\" mechanism, "   << std::endl;
  fout << "// or else the compiler will use C++ name mangling, which will cause" << std::endl;
  fout << "// the symbol IDL_Load to be undefined when IDL tries to load it" << std::endl << std::endl;

  fout << "extern \"C\" {"        << std::endl;
  fout << "  int IDL_Load(void);" << std::endl;
  fout << "}"                     << std::endl << std::endl;

  fout << "int IDL_Load(void)"    << std::endl;
  fout << "{"                     << std::endl;
  
  
  fout << "  // These tables contain information on the functions and procedures " << std::endl;
  fout << "  // that make up the file " << filePrefix << ".dlm. " << std::endl;
  fout << "  // The information contained in these tables must be identical to that " << std::endl;
  fout << "  // contained in " << filePrefix << ".dlm" << std::endl << std::endl << std::endl;
  
  for(unsigned i=0; i < functions_.size(); i++) {
    fout << "  static IDL_SYSFUN_DEF2 function_addr" << i << "[] = {" << std::endl;
    fout << "    {(IDL_SYSRTN_GENERIC) " << functions_[i] << ", \"" << caps(functions_[i]) 
	 << "\", 0, IDL_MAXPARAMS, 0, 0}," << std::endl;
    fout << "  };" << std::endl << std::endl;
  }

  for(unsigned i=0; i < procedures_.size(); i++) {
    fout << "  static IDL_SYSFUN_DEF2 procedure_addr" << i << "[] = {" << std::endl;
    fout << "    {(IDL_SYSRTN_GENERIC) " << procedures_[i] << ", \"" << caps(procedures_[i]) 
    	 << "\", 0, IDL_MAX_ARRAY_DIM, 0, 0}," << std::endl;
    fout << "  };" << std::endl << std::endl;
  }

  fout << std::endl;
  fout << "  // Register our routine. The routines must be specified exactly the " << std::endl;
  fout << "  // same as in " << filePrefix << ".dlm" << std::endl;
  fout << std::endl;

  fout << "  return ";
  for(unsigned i=0; i < functions_.size(); i++) {
    fout << (i==0 ? "" : "\n    &&    ") << "IDL_SysRtnAdd(function_addr" << i 
	 << ", TRUE, IDL_CARRAY_ELTS(function_addr" << i << "))";
  }

  for(unsigned i=0; i < procedures_.size(); i++) {
    fout << "\n    &&    " << "IDL_SysRtnAdd(procedure_addr" << i 
	 << ", FALSE, IDL_CARRAY_ELTS(procedure_addr" << i << "))";
  }

  fout << ";" << std::endl;
  fout << "}" << std::endl;

  fout.close();
}

void IdlGenerator::outputCcFile()
{
  std::ostringstream os;
  std::ostringstream is;

  std::string prefixCopy = sourceFilePrefix_;

  os << dir_ << "/" << outputPrefix_ << "." << outputCcSuffix_; 
  is << dir_ << "/" << sourceFileName_;

  if(os.str() == is.str())
    ThrowError("Output file: " << os.str() << " will overwrite the input");

  // Open the files

  std::ofstream fout(os.str().c_str(), ios::out);
  std::ifstream fin(is.str().c_str());

  os.str("");
  std::string filePrefix = outputPrefix_;

  std::string s;
  while(getline(fin, s)) {
    fout << s << std::endl;
  }

  fin.close();

  fout << "//=======================================================================" << std::endl;
  fout << "// Auto-generated by IdlGenerator from " << sourceFileName_                << std::endl;
  fout << "//"                                                                        << std::endl;
  fout << "// This file contains the definition of the IDL_Load() function"           << std::endl;
  fout << "// required for compilation into a dynamically loadable IDL module"        << std::endl;
  fout << "//=======================================================================" << std::endl << std::endl;

  fout << "// We must declare this function with the extern \"C\" mechanism, "   << std::endl;
  fout << "// or else the compiler will use C++ name mangling, which will cause" << std::endl;
  fout << "// the symbol IDL_Load to be undefined when IDL tries to load it" << std::endl << std::endl;

  fout << "extern \"C\" {"        << std::endl;
  fout << "  int IDL_Load(void);" << std::endl;
  fout << "}"                     << std::endl << std::endl;

  fout << "int IDL_Load(void)"    << std::endl;
  fout << "{"                     << std::endl;
  
  
  fout << "  // These tables contain information on the functions and procedures " << std::endl;
  fout << "  // that make up the file " << filePrefix << ".dlm. " << std::endl;
  fout << "  // The information contained in these tables must be identical to that " << std::endl;
  fout << "  // contained in " << filePrefix << ".dlm" << std::endl << std::endl << std::endl;
  
  for(unsigned i=0; i < functions_.size(); i++) {
    fout << "  static IDL_SYSFUN_DEF2 function_addr" << i << "[] = {" << std::endl;
    fout << "    {(IDL_SYSRTN_GENERIC) " << functions_[i] << ", \"" << caps(functions_[i]) 
	 << "\", 0, IDL_MAXPARAMS, 0, 0}," << std::endl;
    fout << "  };" << std::endl << std::endl;
  }

  for(unsigned i=0; i < procedures_.size(); i++) {
    fout << "  static IDL_SYSFUN_DEF2 procedure_addr" << i << "[] = {" << std::endl;
    fout << "    {(IDL_SYSRTN_GENERIC) " << procedures_[i] << ", \"" << caps(procedures_[i]) 
    	 << "\", 0, IDL_MAX_ARRAY_DIM, 0, 0}," << std::endl;
    fout << "  };" << std::endl << std::endl;
  }

  fout << std::endl;
  fout << "  // Register our routine. The routines must be specified exactly the " << std::endl;
  fout << "  // same as in " << filePrefix << ".dlm" << std::endl;
  fout << std::endl;

  fout << "  return ";
  for(unsigned i=0; i < functions_.size(); i++) {
    fout << (i==0 ? "" : "\n    &&    ") << "IDL_SysRtnAdd(function_addr" << i 
	 << ", TRUE, IDL_CARRAY_ELTS(function_addr" << i << "))";
  }

  for(unsigned i=0; i < procedures_.size(); i++) {
    fout << "\n    &&    " << "IDL_SysRtnAdd(procedure_addr" << i 
	 << ", FALSE, IDL_CARRAY_ELTS(procedure_addr" << i << "))";
  }

  fout << ";" << std::endl;
  fout << "}" << std::endl;

  fout.close();
}

std::string IdlGenerator::caps(std::string inp)
{
  std::string outp = inp;

  for(unsigned i=0; i < outp.size(); i++)
    outp[i] = toupper(outp[i]);

  return outp;
}


void IdlGenerator::outputDlmFile()
{
  std::ostringstream os;

  std::string prefixCopy = sourceFilePrefix_;

  os << dir_ << "/" << outputPrefix_ << ".dlm";

  // Open the file

  std::ofstream fout(os.str().c_str(), ios::out);

  fout << "MODULE " << outputPrefix_ << std::endl;
  fout << "DESCRIPTION dlm file for " << sourceFileName_ << std::endl;
  fout << "VERSION 1.0" << std::endl;
  fout << "SOURCE Auto-generated by IdlGenerator from " << sourceFileName_ << std::endl;
  fout << "BUILD_DATE JAN 8 1998" << std::endl;

  for(unsigned i=0; i < functions_.size(); i++) {
    fout << "FUNCTION " << caps(functions_[i]) << " 0 IDL_MAXPARAMS" << endl;
  }

  for(unsigned i=0; i < procedures_.size(); i++) {
    fout << "PROCEDURE " << caps(procedures_[i]) << " 0 IDL_MAX_ARRAY_DIM" << endl;
  }

  fout.close();
}

void IdlGenerator::setOutputPrefix(std::string prefix)
{
  outputPrefix_ = prefix;
}

void IdlGenerator::setOutputCcSuffix(std::string suffix)
{
  outputCcSuffix_ = suffix;
}
