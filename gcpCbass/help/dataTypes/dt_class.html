<HEAD><TITLE>Datatype Classes.</TITLE></HEAD>
<BODY bgcolor="#add8e6">
<center><a href=../index.html>Index</a></center>
<H1>Datatype Classes.</H1>

Many of the SPT datatypes are derived from the following general
datatype classes. All datatypes of a given class understand the same
syntax and expressions, but they differ in the range of values that
they allow.

<HR>
<DL>
<DT><font color=blue><a name=pathname> <code><b>File and directory path names.</b></code> </a></font>
<P>
<DD> Files and directories are specified using absolute path names. These
     are entered as strings, optionally enclosed in quotes. Path names
     start with one of the following prefixes:

<UL>
<LI><pre>
/           A normal absolute path name.
</pre>
<LI><pre>
~/          A path name relative to the home directory
            of the owner of the control program.</pre>
<LI><pre>
~username/  A path name relative to the home directory
            of the named user.</pre>
<LI><pre>
"$VARIABLE/" A path name who's initial components are taken from the
             specified environment variable. Note that since the script
             language also uses $ to evaluate internal variables and
	     functions, if you use this form of pathname, you must
	     enclose the pathname in quotes to prevent the language
	     from seeing the $.</pre>
</UL>
Note that the relevant file access permissions are those of the owner
of the control program.
</DL>

<HR>
<DL>
<DT><font color=blue><a name=set> <code><b>Set datatypes.</b></code> </a></font>
<P>
<DD> Set datatypes allow the user to simultaneously select one or more
     set members. With one exception, the member names are different
     for each datatype. The exception is the <code>all</code> keyword,
     which denotes the set of all the other members.
     <P>
     <DL>
     <DT> Set Expressions:
     <DD> The following operators are supported:
<UL>
<LI><pre>
a <b>+</b> b           This adds set b to set a.
</pre>
<LI><pre>
a <b>-</b> b           This removes b from set a.
</pre>
</UL>
     <DT> Examples:
     <DD> The first example shows a set composed of receivers rx1, rx2
          and rx10. It demonstrates the use of the <code>'+'</code>
	  operator to include values in a set.
<pre>
 print $Receivers(rx2+rx10+rx1)
 -> rx2+rx10
</pre>

          The second example shows a set composed of all receivers
          except rx3, rx4 and rx6. It demonstrates the use of the
          <code>all</code> option, and the use of the <code>'-'</code>
          operator to remove members from a set.
<pre>
 print $Receivers(all-rx3-rx4-rx6)
 -> rx0+rx1+rx2+rx5+rx7+rx8+rx9+rx10+rx11+rx12
</pre>

          The final example shows that set expressions can contain
	  variables and parentheses.

<pre>
 Receivers foo = rx6+rx7+rx8
 Receivers bar = rx3+rx6
 print $Receivers($foo - ($bar + rx7))
 -> rx8
</pre>
     </DL>
</DL>

<HR>
<DL>
<DT><font color=blue><a name=option> <code><b>Option datatypes.</b></code> </a></font>
<P>
<DD> Option datatypes allow the user to specify one of a set of
     mutually exclusive options. Each option datatype supports a
     different set of options, according to its use. Options are
     represented and entered as one-word names.
</DL>

<HR>
<DL>
<DT><font color=blue><a name=float> <code><b>Floating Point Datatypes.</b></code> </a></font>
<P>
<DD> Each floating point datatype has a different range of values that
     it supports, according to its use. The following are examples of
     how floating point numbers can be entered:
<pre>
 14    14.0    1.4e1     1.4e+1   0.000234     2.34e-4  -3.4
</pre>
     Note that for scientific notation <code>'e'</code> is used
     as the indicator of an exponent. This is the <b>C</b> convention
     for entering double precision numbers. The FORTRAN <code>'D'</code>
     equivalent isn't supported. 
</DL>

<HR>
<DL>
<DT><font color=blue><a name=unsigned> <code><b>Unsigned Integer Datatypes.</b></code> </a></font>
<P>
<DD> Unsigned integer datatypes don't allow negative values. By
     default an unsigned integer is interpretted as a decimal
     number, however the following prefixes can be used to specify
     other bases:

<UL>
<LI><pre>
0b     Binary (base 2).
       The trailing number must written using 1's and 0's.
</pre>
<LI><pre>
0      Octal (base 8).
       The trailing number must be written using digits between
       0 and 7, inclusive.
</pre>
<LI><pre>
0x     Hexadecimal (base 16).
       The trailing number must be written using characters
       0-9 and a-f.
</pre>
</UL>
     Note that you should be careful not to add a leading zero unless
     you want your number to be interpretted as octal.
<P>
     <DL><DT>Examples:
<pre>
 print $Mask(0b1110)   # Binary
 -> 14
 print $Mask(0xff)     # Hexadecimal
 -> 255
 print $Mask(013)      # Octal
 -> 11
 print $mask(13)       # Decimal
 -> 13
</pre>
     </DL>
</DL>

<HR>
<DL>
<DT><font color=blue><a name=sexagesimal> <code><b>Sexagesimal Datatypes.</b></code> </a></font>
<P>
<DD> Sexagesimal datatypes are used for entering angle and time
     related parameters. For example, the following sexagesimal
     numbers all represent the number 23.5075.

<pre>
  23.5075    23:30.45   23:30:27   23:30:27.00
</pre>

     The integral part of the number comes first. Its fractional part
     can then either be expressed as a decimal fraction after a
     decimal point, or it can be expressed as a base 60 fraction. In
     the latter case each base 60 digit of the fraction is introduced
     with a colon and denoted by a decimal integer between 0 and 59. The
     optional fractional part of the final component is expressed as a
     decimal fraction after a decimal point.
</DL>

<HR>

Erik Leitch (Tue Mar 30 21:16:00 PST 2004)
</BODY>
