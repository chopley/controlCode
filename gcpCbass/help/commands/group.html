<HEAD><TITLE>The group datatype.</TITLE></HEAD>
<BODY bgcolor="#add8e6">

<HR>
<font color=blue><a name=group> <code><b>group</b> name {type name, ...}</code> </a></font>
<P>
Create a new aggregate datatype.
<P>
<DL>
<DT> Arguments:
<DD> <DL>
     <DT><code>name</code>
     <DD> The name to give to the new datatype.
     <DT><code>type name, ...</code>
     <DD> The types and names of the members of the datatype.
     </DL>
<P>
<DT> Example:
<DD> The following is a complete example that builds on many of the
     other facilities that are documented in this section. It shows
     how one might use <code>group</code> variables to form observing
     lists, and then shows how such an observing list might be used.
     Please read the comments to learn how it all works.
<pre>

 # Create a new datatype that contains all of the parameters that
 # are needed to observe a given source.

 group Observation {
   Source src,         # The source to be observed.
   Time earliest,      # The earliest time to observe the source.
   Time latest,        # The latest time to observe the source.
   Interval duration   # The desired integration time on the source.
 }

 # Form a list of the above type of group, to form
 # an observing list called mylist.

 listof Observation mylist = {
   {3c345,    03:45, 04:45, 5m},
   {3c286,    03:30, 05:30, 10m},
   {0552+398, 04:50, 07:15, 2m},
 }

 # Iterate sequentially through the above list to observe each
 # of the listed sources as per their associated parameters.
 # Each iteration of the foreach loop sets the variable 'obs' to
 # contain a row of the observing list.

 foreach(Observation obs) $mylist {

   # If the observing window for source $obs.src has passed, avoid
   # waiting for the 24 hours that it might take to come around
   # again. Instead print a warning message and start the next
   # iteration of the loop.

   if($after($obs.latest, LST)) {
     print &quot;Too late to observe &quot;, $obs.src, &quot;\n&quot;
     next
   }

   # If not already in the observing window, wait for its start
   # time to pass.

   until $after($obs.earliest, LST)

   # Track the listed source until either the end of the observing
   # window is reached, or the source has been observed for the
   # desired integration time.

   track $obs.src
   until $after($obs.latest) | $elapsed &gt; $obs.duration

   # Continue on to the next iteration of the foreach loop.
 }

</pre>
<DT> Context:
<DD> Group datatypes are like C struct's and Pascal records. When used
     in <a href=listof.html>lists</a> they act like the rows of
     multi-column tables. Tables composed in this way can be
     processed, one row at a time using <a href=foreach.html>foreach</a>
     loops. Group variables don't have to be used in lists. Indeed,
     the above example could be made more general by moving the
     contents of the foreach loop into a user-defined command with a
     scalar <code>Observation</code> argument. If this command were
     named <code>observe</code> then the foreach loop could then be
     re-written as:

<pre>
 foreach(Observation obs) $mylist {
   observe $obs
 }
</pre>

     The individual members of group variables are refered to by
     appending a period to the name of the group variable, followed by
     the name of the desired member. Thus in the above examples,
     <code>$obs.src</code> refers to the <code>src</code> member,
     which is a variable of type <code>Source</code>.
</DL>

<HR>
Erik Leitch (Tue Mar 30 21:16:10 PST 2004)
</BODY>
